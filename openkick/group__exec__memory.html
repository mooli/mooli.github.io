<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>openkick: exec.library memory handling</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openkick
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#enum-members">Enumerations</a>  </div>
  <div class="headertitle">
<div class="title">exec.library memory handling</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexec_1_1Heap.html">exec::Heap</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">an allocatable memory zone [AmigaOS struct MemHeader]  <a href="classexec_1_1Heap.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexec_1_1Heap_1_1Chunk.html">exec::Heap::Chunk</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">a chunk of unallocated memory within a <a class="el" href="classexec_1_1Heap.html" title="an allocatable memory zone [AmigaOS struct MemHeader] ">Heap</a> [AmigaOS struct MemChunk]  <a href="classexec_1_1Heap_1_1Chunk.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexec_1_1HeapList.html">exec::HeapList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classexec_1_1List.html" title="a simple doubly-linked list of Node [AmigaOS struct List] ">List</a> of <a class="el" href="classexec_1_1Heap.html" title="an allocatable memory zone [AmigaOS struct MemHeader] ">Heap</a>; used as the system memory pool.  <a href="classexec_1_1HeapList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexec_1_1MemEntry.html">exec::MemEntry</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">input and output of AllocEntry(), ROMTags, and used by Tasks for memory autorelease [AmigaOS struct MemList]  <a href="classexec_1_1MemEntry.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classexec_1_1MemEntryList.html">exec::MemEntryList</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classexec_1_1List.html" title="a simple doubly-linked list of Node [AmigaOS struct List] ">List</a> of <a class="el" href="classexec_1_1MemEntry.html" title="input and output of AllocEntry(), ROMTags, and used by Tasks for memory autorelease [AmigaOS struct M...">MemEntry</a>; used by Tasks for memory autorelease.  <a href="classexec_1_1MemEntryList.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ga21cfd5c98cd8ce112d35cb2e31e194e3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__exec__memory.html#ga21cfd5c98cd8ce112d35cb2e31e194e3">exec::Heap::Attributes</a> : uint16_t { <br />
&#160;&#160;<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3a9ae6151caba9fc4b5da4efb4f19bad8f">exec::Heap::MEMF_ANY</a> = 0, 
<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3a44ef10c1593affe04d646ee3b89096d4">exec::Heap::MEMF_PUBLIC</a> = 1, 
<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3a0be88534be48d0e71a3ffef6d68969b3">exec::Heap::MEMF_CHIP</a> = 2, 
<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3ab5801b6435fcea7ff7d3b380fbe6d1c3">exec::Heap::MEMF_FAST</a> = 4, 
<br />
&#160;&#160;<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3ad745e256e723bbcac5e74a7e1b204cb6">exec::Heap::MEMF_LOCAL</a> = 0x100, 
<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3a43b93ff46b8eb7752ab84ee4806cc9a1">exec::Heap::MEMF_DMA24</a> = 0x200, 
<a class="el" href="group__exec__memory.html#gga21cfd5c98cd8ce112d35cb2e31e194e3aaa7401de82f2d5331fc865c53f2d6226">exec::Heap::MEMF_KICK</a> = 0x400
<br />
 }<tr class="memdesc:ga21cfd5c98cd8ce112d35cb2e31e194e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory attributes  <a href="group__exec__memory.html#ga21cfd5c98cd8ce112d35cb2e31e194e3">More...</a><br /></td></tr>
<tr class="separator:ga21cfd5c98cd8ce112d35cb2e31e194e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
<tr class="memitem:ga7dd8b90fda92831d65ba2168b7013df4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__exec__memory.html#ga7dd8b90fda92831d65ba2168b7013df4">exec::Heap::Options</a> : uint16_t { <br />
&#160;&#160;<a class="el" href="group__exec__memory.html#gga7dd8b90fda92831d65ba2168b7013df4a8ea15daba38f3beb80cf98a3d9c9c4e2">exec::Heap::MEMF_NONE</a> = 0, 
<a class="el" href="group__exec__memory.html#gga7dd8b90fda92831d65ba2168b7013df4ac83e01b36376d3e191bd58aeb9aeea4f">exec::Heap::MEMF_CLEAR</a> = 0x1, 
<a class="el" href="group__exec__memory.html#gga7dd8b90fda92831d65ba2168b7013df4a4614c8250448bb55e8625e2d2ada3528">exec::Heap::MEMF_REVERSE</a> = 0x4, 
<a class="el" href="group__exec__memory.html#gga7dd8b90fda92831d65ba2168b7013df4a9766173243a0b497474ec09eb9e90db3">exec::Heap::MEMF_NO_EXPUNGE</a> = 0x800, 
<br />
&#160;&#160;<a class="el" href="group__exec__memory.html#gga7dd8b90fda92831d65ba2168b7013df4ac583d855b55d795eb7507702cc261bfe">exec::Heap::MEMF_LARGEST</a> = 0x2, 
<a class="el" href="group__exec__memory.html#gga7dd8b90fda92831d65ba2168b7013df4a1fb42715bca73a31131f5d0e730815c8">exec::Heap::MEMF_TOTAL</a> = 0x8
<br />
 }<tr class="memdesc:ga7dd8b90fda92831d65ba2168b7013df4"><td class="mdescLeft">&#160;</td><td class="mdescRight">memory requirements; may also include values from Heap::Type  <a href="group__exec__memory.html#ga7dd8b90fda92831d65ba2168b7013df4">More...</a><br /></td></tr>
<tr class="separator:ga7dd8b90fda92831d65ba2168b7013df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>write properly</dd></dl>
<p>An Amiga system can contain memory of different performance and visibility to hardware devices, and which is scattered all over the memory map. A Heap refers to one such memory zone, and contains the performance flags, the start and end address, and the amount free in the zone. The type of memory is recorded in the MEMF_* flags.</p>
<p>HeapList point to a singly-linked list of MemoryChunks. A MemoryChunk is a chunk of free memory. Initially, a Heap will point to a single MemoryChunk that covers the whole zone, and if all memory in the zone is allocated, this will be nullptr. MemoryChunks are linked to each other in ascending order of address so as to allow the deallocator to cheaply determine whether MemoryChunks may be merged or not.</p>
<p>Classic AmigaOS provides global Allocate()/DeAllocate() to allocate and free from a specific Heap, AllocMem()/FreeMem() as malloc/free equivalents, AllocEntry()/FreeEntry() as a means of allocating from multiple zones atomically (ish), AllocAbs() to obtain memory at a specific address, AvailMem() to query free memory, AddMemList() to add a new memory zone, and CopyMem()/CopyMemQuick() as memcpy equivalents.</p>
<p>AllocEntry()/FreeEntry() use a struct MemList, which starts is slightly confusing terminology as it's not an AmigaOS List. A MemList is a Node followed by an array of MemEntry, which is a union that is essentially a (requirement, size) tuple for allocation requests and an (address, size) tuple for the results of that allocation. The Node header exists so that responses may be linked together in a Task's tc_mementry (FIXME) field, and they will be automatically freed when a task exits.</p>
<p>One thing to note is that in AmigaOS, allocations do not record their size like malloc/free and new/delete do, and the size needs to be provided at deallocation time. This means that implementations of new/delete need to squirrel away the space needed for the size <em>without</em> breaking the ABI.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>split the Heap::Flags into attributes and options so that we can use a Flags type for memory attributes.</dd></dl>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="ga21cfd5c98cd8ce112d35cb2e31e194e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__exec__memory.html#ga21cfd5c98cd8ce112d35cb2e31e194e3">exec::Heap::Attributes</a> : <a class="el" href="types_8hpp.html#a273cf69d639a59973b6019625df33e30">uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory attributes </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3a9ae6151caba9fc4b5da4efb4f19bad8f"></a>MEMF_ANY&#160;</td><td class="fielddoc">
<p>any kind of memory </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3a44ef10c1593affe04d646ee3b89096d4"></a>MEMF_PUBLIC&#160;</td><td class="fielddoc">
<p>memory will not be swapped out (unused) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3a0be88534be48d0e71a3ffef6d68969b3"></a>MEMF_CHIP&#160;</td><td class="fielddoc">
<p>memory is visible to custom chips </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3ab5801b6435fcea7ff7d3b380fbe6d1c3"></a>MEMF_FAST&#160;</td><td class="fielddoc">
<p>memory is not visible to custom chips </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3ad745e256e723bbcac5e74a7e1b204cb6"></a>MEMF_LOCAL&#160;</td><td class="fielddoc">
<p>memory does not vanish on reset (V36+) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3a43b93ff46b8eb7752ab84ee4806cc9a1"></a>MEMF_DMA24&#160;</td><td class="fielddoc">
<p>memory is visible to Zorro II devices (V36+) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga21cfd5c98cd8ce112d35cb2e31e194e3aaa7401de82f2d5331fc865c53f2d6226"></a>MEMF_KICK&#160;</td><td class="fielddoc">
<p>memory available in early startup (V39+) </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00019">19</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ga7dd8b90fda92831d65ba2168b7013df4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="group__exec__memory.html#ga7dd8b90fda92831d65ba2168b7013df4">exec::Heap::Options</a> : <a class="el" href="types_8hpp.html#a273cf69d639a59973b6019625df33e30">uint16_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>memory requirements; may also include values from <a class="el" href="group__exec__list.html#ga1f7e67185ec5c5208dcb866ee0ab0291" title="the different node types that may be placed into the type field of a Node ">Heap::Type</a> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="gga7dd8b90fda92831d65ba2168b7013df4a8ea15daba38f3beb80cf98a3d9c9c4e2"></a>MEMF_NONE&#160;</td><td class="fielddoc">
<p>no options requested </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7dd8b90fda92831d65ba2168b7013df4ac83e01b36376d3e191bd58aeb9aeea4f"></a>MEMF_CLEAR&#160;</td><td class="fielddoc">
<p>clear memory before returning </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7dd8b90fda92831d65ba2168b7013df4a4614c8250448bb55e8625e2d2ada3528"></a>MEMF_REVERSE&#160;</td><td class="fielddoc">
<p>allocate memory from the top of the pool (V36+) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7dd8b90fda92831d65ba2168b7013df4a9766173243a0b497474ec09eb9e90db3"></a>MEMF_NO_EXPUNGE&#160;</td><td class="fielddoc">
<p>fail rather than cause GC (V39+) </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7dd8b90fda92831d65ba2168b7013df4ac583d855b55d795eb7507702cc261bfe"></a>MEMF_LARGEST&#160;</td><td class="fielddoc">
<p>return the largest free chunk </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="gga7dd8b90fda92831d65ba2168b7013df4a1fb42715bca73a31131f5d0e730815c8"></a>MEMF_TOTAL&#160;</td><td class="fielddoc">
<p>return the total memory size </p>
</td></tr>
</table>

<p>Definition at line <a class="el" href="memory_8hpp_source.html#l00030">30</a> of file <a class="el" href="memory_8hpp_source.html">memory.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 19 2016 09:41:24 for openkick by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
