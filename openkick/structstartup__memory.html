<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>openkick: startup_memory Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">openkick
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="structstartup__memory-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">startup_memory Struct Reference<div class="ingroups"><a class="el" href="group__todo.html">stuff that still needs doing</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A container for startup memory.  
 <a href="structstartup__memory.html#details">More...</a></p>
<div class="dynheader">
Inheritance diagram for startup_memory:</div>
<div class="dyncontent">
<div class="center"><img src="structstartup__memory__inherit__graph.png" border="0" usemap="#startup__memory_inherit__map" alt="Inheritance graph"/></div>
<map name="startup__memory_inherit__map" id="startup__memory_inherit__map">
<area shape="rect" id="node2" href="structexec_1_1Buffer.html" title="exec::Buffer" alt="" coords="16,5,90,28"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div class="dynheader">
Collaboration diagram for startup_memory:</div>
<div class="dyncontent">
<div class="center"><img src="structstartup__memory__coll__graph.png" border="0" usemap="#startup__memory_coll__map" alt="Collaboration graph"/></div>
<map name="startup__memory_coll__map" id="startup__memory_coll__map">
<area shape="rect" id="node2" href="structexec_1_1Buffer.html" title="exec::Buffer" alt="" coords="5,98,80,121"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7eb1969076b4ca3f72ce0c88b8c5bf94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#a7eb1969076b4ca3f72ce0c88b8c5bf94">startup_memory</a> (<a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a> start_, <a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a> end_)</td></tr>
<tr class="separator:a7eb1969076b4ca3f72ce0c88b8c5bf94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1efe9e3785f5543ee214d033eb1013f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structexec_1_1Buffer.html#a10aa3b8aac6520c46a073b0e5f93f8f6">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#ad1efe9e3785f5543ee214d033eb1013f">carve_bottom</a> (<a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a> size_)</td></tr>
<tr class="separator:ad1efe9e3785f5543ee214d033eb1013f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20371e45aa1f0142619f46ab5ac72d7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structexec_1_1Buffer.html#a10aa3b8aac6520c46a073b0e5f93f8f6">Buffer</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#a20371e45aa1f0142619f46ab5ac72d7d">carve_top</a> (<a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a> size_)</td></tr>
<tr class="separator:a20371e45aa1f0142619f46ab5ac72d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebf0889438b923ba2d78ad9172bbf891"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#aebf0889438b923ba2d78ad9172bbf891">empty</a> (void) const </td></tr>
<tr class="separator:aebf0889438b923ba2d78ad9172bbf891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad501c88ce52d2b238356b48d1401e70d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#ad501c88ce52d2b238356b48d1401e70d">operator bool</a> (void) const </td></tr>
<tr class="separator:ad501c88ce52d2b238356b48d1401e70d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae843a05f6059c53f829596974a7fda30"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#ae843a05f6059c53f829596974a7fda30">operator const void *</a> (void) const </td></tr>
<tr class="separator:ae843a05f6059c53f829596974a7fda30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ba5a0a56669519505c30e98ac352b60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#a7ba5a0a56669519505c30e98ac352b60">probe_a3000_ram</a> (<a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>=(256&lt;&lt; 10))</td></tr>
<tr class="memdesc:a7ba5a0a56669519505c30e98ac352b60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probes for A3000-style RAM.  <a href="#a7ba5a0a56669519505c30e98ac352b60">More...</a><br /></td></tr>
<tr class="separator:a7ba5a0a56669519505c30e98ac352b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29ebc914fa9836d9496cffbe2067f91b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#a29ebc914fa9836d9496cffbe2067f91b">probe_chip_ram</a> (<a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>=(256&lt;&lt; 10))</td></tr>
<tr class="memdesc:a29ebc914fa9836d9496cffbe2067f91b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probes for Chip RAM.  <a href="#a29ebc914fa9836d9496cffbe2067f91b">More...</a><br /></td></tr>
<tr class="separator:a29ebc914fa9836d9496cffbe2067f91b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2d778af767376bcd86e4cde7ed6a2ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#aa2d778af767376bcd86e4cde7ed6a2ed">probe_slow_ram</a> (<a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>=4096)</td></tr>
<tr class="memdesc:aa2d778af767376bcd86e4cde7ed6a2ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probes for Slow RAM.  <a href="#aa2d778af767376bcd86e4cde7ed6a2ed">More...</a><br /></td></tr>
<tr class="separator:aa2d778af767376bcd86e4cde7ed6a2ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a499d6d5e57b36d176247e867fd3c3f3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#a499d6d5e57b36d176247e867fd3c3f3d">size</a> (void) const </td></tr>
<tr class="separator:a499d6d5e57b36d176247e867fd3c3f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7bebbaab382f4e6a7fc979ef1432e59d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#a7bebbaab382f4e6a7fc979ef1432e59d">is_24bit</a> (void)</td></tr>
<tr class="memdesc:a7bebbaab382f4e6a7fc979ef1432e59d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if the CPU has a 24 or 32 bit address bus.  <a href="#a7bebbaab382f4e6a7fc979ef1432e59d">More...</a><br /></td></tr>
<tr class="separator:a7bebbaab382f4e6a7fc979ef1432e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17815c0bbdb623724e2aec003f467655"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#a17815c0bbdb623724e2aec003f467655">is_repeat</a> (void *, void *)</td></tr>
<tr class="memdesc:a17815c0bbdb623724e2aec003f467655"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if two memory locations are aliased to each other.  <a href="#a17815c0bbdb623724e2aec003f467655">More...</a><br /></td></tr>
<tr class="separator:a17815c0bbdb623724e2aec003f467655"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7230cc9aa2b6510bfb67744b5dad68"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#a6e7230cc9aa2b6510bfb67744b5dad68">is_writable</a> (void *)</td></tr>
<tr class="memdesc:a6e7230cc9aa2b6510bfb67744b5dad68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests to see if a memory location is RAM.  <a href="#a6e7230cc9aa2b6510bfb67744b5dad68">More...</a><br /></td></tr>
<tr class="separator:a6e7230cc9aa2b6510bfb67744b5dad68"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ae73ef354e5967a279b1b6c601a3e850f"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#ae73ef354e5967a279b1b6c601a3e850f">end</a></td></tr>
<tr class="separator:ae73ef354e5967a279b1b6c601a3e850f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74d8672ada4e0f656d20520c0382ec50"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structexec_1_1Buffer.html#a74d8672ada4e0f656d20520c0382ec50">start</a></td></tr>
<tr class="separator:a74d8672ada4e0f656d20520c0382ec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa1d905d59fe13371bdda55925e7c3ba4"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#aa1d905d59fe13371bdda55925e7c3ba4">pat5</a> =0x55555555</td></tr>
<tr class="memdesc:aa1d905d59fe13371bdda55925e7c3ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer constant with repeated binary digits 01, useful for memory testing.  <a href="#aa1d905d59fe13371bdda55925e7c3ba4">More...</a><br /></td></tr>
<tr class="separator:aa1d905d59fe13371bdda55925e7c3ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad250cb07465dc4dc699740d07854b731"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structstartup__memory.html#ad250cb07465dc4dc699740d07854b731">patA</a> =0xAAAAAAAA</td></tr>
<tr class="memdesc:ad250cb07465dc4dc699740d07854b731"><td class="mdescLeft">&#160;</td><td class="mdescRight">The integer constant with repeated binary digits 10, useful for memory testing.  <a href="#ad250cb07465dc4dc699740d07854b731">More...</a><br /></td></tr>
<tr class="separator:ad250cb07465dc4dc699740d07854b731"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A container for startup memory. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>ingroup? </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00046">46</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a7eb1969076b4ca3f72ce0c88b8c5bf94"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">startup_memory::startup_memory </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>start_</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a>&#160;</td>
          <td class="paramname"><em>end_</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00052">52</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ad1efe9e3785f5543ee214d033eb1013f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structexec_1_1Buffer.html#a10aa3b8aac6520c46a073b0e5f93f8f6">Buffer</a> exec::Buffer::carve_bottom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>size_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00021">21</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a20371e45aa1f0142619f46ab5ac72d7d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structexec_1_1Buffer.html#a10aa3b8aac6520c46a073b0e5f93f8f6">Buffer</a> exec::Buffer::carve_top </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>size_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00026">26</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aebf0889438b923ba2d78ad9172bbf891"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool exec::Buffer::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00018">18</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7bebbaab382f4e6a7fc979ef1432e59d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool startup_memory::is_24bit </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests to see if the CPU has a 24 or 32 bit address bus. </p>
<dl class="section warning"><dt>Warning</dt><dd>This temporarily corrupts eight bytes of memory at locations 0 and 0x07000000. You should ensure that you have not loaded this routine at such an address, and have no active interrupt handlers or DMA using such addresses.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>true if the CPU has a 24 bit address bus, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00149">149</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a17815c0bbdb623724e2aec003f467655"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool startup_memory::is_repeat </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests to see if two memory locations are aliased to each other. </p>
<dl class="section warning"><dt>Warning</dt><dd>This temporarily corrupts four bytes of memory each at the locations with addresses <em>first</em> and <em>second</em> . You should ensure that you have not loaded this routine at such an address, and have no active interrupt handlers or DMA using such addresses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the address of the first location </td></tr>
    <tr><td class="paramname">second</td><td>the address of the second location</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if <em>first</em> and <em>second</em> access the same physical location </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00078">78</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e7230cc9aa2b6510bfb67744b5dad68"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool startup_memory::is_writable </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>address</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tests to see if a memory location is RAM. </p>
<dl class="section warning"><dt>Warning</dt><dd>This temporarily corrupts eight bytes of memory starting at the address <em>address</em> . You should ensure that you have not loaded this routine at such an address, and have no active interrupt handlers or DMA using such addresses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>the address to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the location is RAM, false otherwise </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00109">109</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad501c88ce52d2b238356b48d1401e70d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exec::Buffer::operator bool </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00019">19</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae843a05f6059c53f829596974a7fda30"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">exec::Buffer::operator const void * </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00020">20</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ba5a0a56669519505c30e98ac352b60"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startup_memory::probe_a3000_ram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>step</em> = <code>(256&lt;&lt;10)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probes for A3000-style RAM. </p>
<p>A3000 RAM appears in different forms depending on the system.</p>
<p>Under UAE, A3000 RAM grows up from 0x07000000 and continues up indefinitely. However, since Kickstart likes to map Zorro III cards at 0x40000000, we cap this bank to that address (giving an effective maximum of 912MB) to keep things neat.</p>
<p>On an A4000, the RAM grows down from 0x07ffffff. This bank has a maximum size of 16MB and thus the lowest possible address is 0x07000000. A slight added complication is MapROM hardware on the A3640 CPU board which can steal the top 512kB of RAM for reset-proof Kickstart shadowing.</p>
<p>How the memory in a real A3000 is mapped is unknown, but it's assumed that it's a contiguous chunk somewhere in the 16MB area between 0x07000000 and 0x07ffffff.</p>
<p>The approach used to locate RAM here is to scan from the bottom of the memory range until we find RAM (thus able to find memory in an A4000 with less than 16MB of RAM), and then keep going until it disappears again.</p>
<dl class="section warning"><dt>Warning</dt><dd>This temporarily corrupts eight bytes of memory at all locations in the test range with addresses that are multiples of 256kB. You should ensure that you have not loaded this routine at such an address, and have no active interrupt handlers or DMA using such addresses.</dd></dl>
<dl class="bug"><dt><b><a class="el" href="bug.html#_bug000001">Bug:</a></b></dt><dd>This won't work on a machine with a 24 bit address bus, and will misdetect Chip RAM (and any configured Zorro II RAM) as A3000 RAM.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the (virtual) address of the start of Slow RAM </td></tr>
    <tr><td class="paramname">end</td><td>the (virtual) address of the end of Slow RAM </td></tr>
    <tr><td class="paramname">step</td><td>the step size for testing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structstartup__memory.html" title="A container for startup memory. ">startup_memory</a> containing the usable address range of A3000 RAM. </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00292">292</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a29ebc914fa9836d9496cffbe2067f91b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startup_memory::probe_chip_ram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>step</em> = <code>(256&lt;&lt;10)</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probes for Chip RAM. </p>
<p>Chip RAM appears from physical location 0 upwards, with a maximum of 2MB of Chip RAM in real Amigas, and 8MB under UAE emulation. Where there is less than 2MB of Chip RAM present in the system, the RAM will repeat throughout the 2MB range due to incomplete address decoding.</p>
<p>This RAM is tested by walking upwards through the range until one finds a location that is aliased with the first location (because of the incomplete address decoding) or a location that is not RAM (because we've walked off the end).</p>
<dl class="section warning"><dt>Warning</dt><dd>This temporarily corrupts eight bytes of memory at all locations in the test range with addresses that are multiples of the <code>step</code> . You should ensure that you have not loaded this routine at such an address, and have no active interrupt handlers or DMA using such addresses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the (virtual) address of the start of Chip RAM </td></tr>
    <tr><td class="paramname">end</td><td>the (virtual) address of the end of Chip RAM </td></tr>
    <tr><td class="paramname">step</td><td>the step size for testing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structstartup__memory.html" title="A container for startup memory. ">startup_memory</a> containing the usable address range of Chip RAM </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00188">188</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa2d778af767376bcd86e4cde7ed6a2ed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void startup_memory::probe_slow_ram </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a>&#160;</td>
          <td class="paramname"><em>step</em> = <code>4096</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probes for Slow RAM. </p>
<p>Slow RAM appears from physical location 0xC00000 upwards with a theoretical top address of 0xDFF000 where it meets the custom chips. Real Amigas have up to 512kB of this, whereas UAE will emulate up to 1984kB (with a top address of 0xDF0000.) The custom chips will appear where there is no RAM, so a memory test has to be specially aware of this and not poke random registers as if they were RAM.</p>
<dl class="section warning"><dt>Warning</dt><dd>This temporarily corrupts the four bytes of memory at all locations in the test range with addresses that are multiples of the <code>step</code> plus 0x1c, 0x1d, 0x9a and 0x9b (the offsets of custom chip registers INTENAR and INTENA). You should ensure that you have not loaded this routine at such an address, and have no active interrupt handlers or DMA using such addresses.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">start</td><td>the (virtual) address of the start of Slow RAM </td></tr>
    <tr><td class="paramname">end</td><td>the (virtual) address of the end of Slow RAM </td></tr>
    <tr><td class="paramname">step</td><td>the step size for testing</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>a <a class="el" href="structstartup__memory.html" title="A container for startup memory. ">startup_memory</a> containing the usable address range of Slow RAM </dd></dl>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00225">225</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a499d6d5e57b36d176247e867fd3c3f3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8hpp.html#a29d85914ddff32967d85ada69854206d">size_t</a> exec::Buffer::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00017">17</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ae73ef354e5967a279b1b6c601a3e850f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char * exec::Buffer::end</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00013">13</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa1d905d59fe13371bdda55925e7c3ba4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a> startup_memory::pat5 =0x55555555</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The integer constant with repeated binary digits 01, useful for memory testing. </p>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00050">50</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="ad250cb07465dc4dc699740d07854b731"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="types_8hpp.html#a06896e8c53f721507066c079052171f8">uint32_t</a> startup_memory::patA =0xAAAAAAAA</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The integer constant with repeated binary digits 10, useful for memory testing. </p>

<p>Definition at line <a class="el" href="execbase_8cpp_source.html#l00048">48</a> of file <a class="el" href="execbase_8cpp_source.html">execbase.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a74d8672ada4e0f656d20520c0382ec50"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* exec::Buffer::start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="buffer_8hpp_source.html#l00013">13</a> of file <a class="el" href="buffer_8hpp_source.html">buffer.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li>exec/<a class="el" href="execbase_8cpp_source.html">execbase.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Tue Jan 19 2016 09:41:24 for openkick by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.10
</small></address>
</body>
</html>
